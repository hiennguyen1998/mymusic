import VideoInfo, { Format, AdaptiveFormat } from './models/VideoInfo';
export default class VideoData {
    readonly videoId: string;
    readonly videoTitle: string;
    readonly videoTime: string;
    readonly videoDescription: string;
    private readonly videoInfo;
    constructor(videoId: string, videoInfo: VideoInfo);
    /**
     * Returns a `videoData` object with link as specified by `link`.
     * @param link Stores a YouTube link
     */
    static fromLink(link: string): Promise<VideoData>;
    /**
     * Extracts the video id from the YouTube link.
     * @param url Stores the YouTube link
     */
    private static getVideoId;
    /**
     * Returns true if `videoInfo` is valid.
     * @param videoInfo Stores the videoInfo object
     */
    private static validateParsedResponse;
    /**
     * Extracts `this.videoTitle` from `this.videoInfo` and stores.
     */
    private getVideoTitle;
    /**
     * Extracts `this.videoTime` from `this.videoInfo` and stores.
     */
    private getVideoTime;
    /**
     * Extracts `this.videoDescription` from `this.videoInfo` and stores.
     */
    private getVideoDescription;
    /**
     * Returns a promise which resolves with a `videoInfo` object.
     * @param videoId Stores the video id
     */
    private static getVideoInfo;
    /**
     * Returns the download `url` and other details about the specific `format`
     * searched by `quality`.
     * @param qualityLabel Stores the video quality
     * @param options Stores special options like audioOnly or videoOnly
     */
    fetchFormatData(qualityLabel: string, options?: {
        audioOnly?: boolean;
        videoOnly?: boolean;
    }): {
        url: string;
        fmt: Format | AdaptiveFormat;
    };
    /**
     * Returns the download `url` and other details about the specific `format`
     * searching by `itag`.
     * @param itag Stores the YouTube itag
     */
    fetchFormatDataByItag(itag: number): {
        url: string;
        fmt: Format | AdaptiveFormat;
    };
    /**
     * Returns the size of the YouTube content, in `bytes`.
     * @param qualityLabelOrItag Stores the quality or itag
     * @param options Stores special options like audioOnly or videoOnly
     */
    size(qualityLabelOrItag: string | number, options?: {
        audioOnly?: boolean;
        videoOnly?: boolean;
    }): number;
    /**
     * Returns `id`, `title`, `time`, and `description`.
     */
    all(): {
        id: string;
        title: string;
        time: string;
        description: string;
    };
}
