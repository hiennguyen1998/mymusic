"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
exports.__esModule = true;
var axios_1 = __importDefault(require("axios"));
var url_1 = require("url");
var between_1 = __importDefault(require("./utils/between"));
var signature_1 = __importStar(require("./utils/signature"));
var VideoData = /** @class */ (function () {
    function VideoData(videoId, videoInfo) {
        this.videoId = videoId;
        this.videoInfo = videoInfo;
        this.videoTitle = this.getVideoTitle();
        this.videoTime = this.getVideoTime();
        this.videoDescription = this.getVideoDescription();
    }
    /**
     * Returns a `videoData` object with link as specified by `link`.
     * @param link Stores a YouTube link
     */
    VideoData.fromLink = function (link) {
        return __awaiter(this, void 0, void 0, function () {
            var videoId, videoInfo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        videoId = VideoData.getVideoId(link);
                        return [4 /*yield*/, VideoData.getVideoInfo(videoId)];
                    case 1:
                        videoInfo = _a.sent();
                        VideoData.validateParsedResponse(videoInfo);
                        return [2 /*return*/, new VideoData(videoId, videoInfo)];
                }
            });
        });
    };
    /**
     * Extracts the video id from the YouTube link.
     * @param url Stores the YouTube link
     */
    VideoData.getVideoId = function (url) {
        var urlRegexPrimary = /^(["']|)((((https)|(http)):\/\/|)(www\.|m\.|music\.|gaming\.|)youtube\.com\/watch\?v=)[\w\-&=.]+(["']|)$/i;
        var urlRegexSecondary = /^(["']|)(((https)|(http)):\/\/|)youtu.be\/[\w\-&=.]+(["']|)$/i;
        if (!urlRegexPrimary.test(url) && !urlRegexSecondary.test(url)) {
            throw new Error('Invalid URL.');
        }
        return url.split('watch?v=')[1].split('&')[0];
    };
    /**
     * Returns true if `videoInfo` is valid.
     * @param videoInfo Stores the videoInfo object
     */
    VideoData.validateParsedResponse = function (videoInfo) {
        if (videoInfo.playabilityStatus.status === 'UNPLAYABLE') {
            return new Error('Video Unplayable');
        }
        if (!videoInfo.streamingData) {
            return new Error('Invalid videoInfo.streamingData');
        }
        return true;
    };
    /**
     * Extracts `this.videoTitle` from `this.videoInfo` and stores.
     */
    VideoData.prototype.getVideoTitle = function () {
        return this.videoInfo.videoDetails.title;
    };
    /**
     * Extracts `this.videoTime` from `this.videoInfo` and stores.
     */
    VideoData.prototype.getVideoTime = function () {
        var lengthSeconds = Number(this.videoInfo.videoDetails.lengthSeconds);
        var minute = 60;
        var hour = 60 * minute;
        var hours = Math.floor(lengthSeconds / hour);
        lengthSeconds -= hour * hours;
        var minutes = Math.floor(lengthSeconds / minute);
        lengthSeconds -= minute * minutes;
        var seconds = lengthSeconds;
        function lpad(target, padString, length) {
            var str = target;
            while (str.length < length)
                str = padString + str;
            return str;
        }
        var time = lpad(hours.toString(), '0', 2);
        time += ":" + lpad(minutes.toString(), '0', 2);
        time += ":" + lpad(seconds.toString(), '0', 2);
        return time;
    };
    /**
     * Extracts `this.videoDescription` from `this.videoInfo` and stores.
     */
    VideoData.prototype.getVideoDescription = function () {
        return this.videoInfo.videoDetails.shortDescription;
    };
    /**
     * Returns a promise which resolves with a `videoInfo` object.
     * @param videoId Stores the video id
     */
    VideoData.getVideoInfo = function (videoId) {
        return __awaiter(this, void 0, void 0, function () {
            var videoIdRegex, body, jsonStr, config, playerResponse, eurl, response, playabilityStatus, videoDetails, streamingData, html5playerfileResponse, tokens, videoInfo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        videoIdRegex = /^[\w_-]+$/;
                        if (!videoIdRegex.test(videoId)) {
                            throw new Error('Invalid videoId.');
                        }
                        return [4 /*yield*/, axios_1["default"].get("https://www.youtube.com/watch?v=" + videoId + "&hl=en&bpctr=" + Math.ceil(Date.now() / 1000), {
                                headers: {
                                    'User-Agent': ''
                                }
                            })];
                    case 1:
                        body = _a.sent();
                        jsonStr = between_1["default"](body.data, 'ytplayer.config = ', '</script>');
                        try {
                            config = JSON.parse(jsonStr.slice(0, jsonStr.lastIndexOf(';ytplayer.load')));
                        }
                        catch (err) {
                            if (err.name === 'SyntaxError') {
                                return [2 /*return*/, this.getVideoInfo(videoId)];
                            }
                            throw err;
                        }
                        playerResponse = JSON.parse(config.args.player_response);
                        if (!!config.args.player_response) return [3 /*break*/, 3];
                        eurl = "https://youtube.googleapis.com/v/" + videoId;
                        return [4 /*yield*/, axios_1["default"].get("https://www.youtube.com/get_video_info?video_id=" + videoId + "&el=embedded&eurl=" + eurl + "&sts=18333")];
                    case 2:
                        response = _a.sent();
                        playerResponse = JSON.parse(Object.fromEntries(new url_1.URLSearchParams(response.data)).player_response);
                        _a.label = 3;
                    case 3:
                        playabilityStatus = playerResponse.playabilityStatus, videoDetails = playerResponse.videoDetails, streamingData = playerResponse.streamingData;
                        return [4 /*yield*/, axios_1["default"].get("https://www.youtube.com" + config.assets.js)];
                    case 4:
                        html5playerfileResponse = _a.sent();
                        tokens = signature_1["default"](html5playerfileResponse.data);
                        videoInfo = {
                            playabilityStatus: playabilityStatus,
                            videoDetails: videoDetails,
                            streamingData: streamingData,
                            tokens: tokens
                        };
                        return [2 /*return*/, videoInfo];
                }
            });
        });
    };
    /**
     * Returns the download `url` and other details about the specific `format`
     * searched by `quality`.
     * @param qualityLabel Stores the video quality
     * @param options Stores special options like audioOnly or videoOnly
     */
    VideoData.prototype.fetchFormatData = function (qualityLabel, options) {
        var audioMappings = {
            high: 'AUDIO_QUALITY_HIGH',
            medium: 'AUDIO_QUALITY_MEDIUM',
            low: 'AUDIO_QUALITY_LOW',
            AUDIO_QUALITY_HIGH: 'AUDIO_QUALITY_HIGH',
            AUDIO_QUALITY_MEDIUM: 'AUDIO_QUALITY_MEDIUM',
            AUDIO_QUALITY_LOW: 'AUDIO_QUALITY_LOW'
        };
        var opts = options;
        if (!opts) {
            opts = { audioOnly: false, videoOnly: false };
        }
        else if (opts.audioOnly && opts.videoOnly) {
            throw new Error('audioOnly and videoOnly can\'t be true simultaneously.');
        }
        var url;
        var fmt;
        var tokens = this.videoInfo.tokens;
        function common(format) {
            if (format.url) {
                return format.url;
            }
            var link = Object.fromEntries(new url_1.URLSearchParams(format.cipher || format.signatureCipher));
            var sig = tokens && link.s ? signature_1.decipher(tokens, link.s) : null;
            return link.url + "&" + (link.sp || 'sig') + "=" + sig;
        }
        function callback(format) {
            var mimeType = 'video/mp4';
            if (format.mimeType.includes(mimeType)
                && (qualityLabel === 'any' ? true : format.qualityLabel === qualityLabel)) {
                url = common(format);
                fmt = format;
            }
        }
        function audioCallback(format) {
            var mimeType = 'audio/mp4';
            if (format.mimeType.includes(mimeType)
                && (qualityLabel === 'any' ? true : format.audioQuality === audioMappings[qualityLabel])) {
                url = common(format);
                fmt = format;
            }
        }
        // TODO: url is always the last URL in the array, check if this needs to be changed
        if (!opts.audioOnly && !opts.videoOnly) {
            this.videoInfo.streamingData.formats.forEach(callback);
        }
        else if (options.videoOnly) {
            this.videoInfo.streamingData.adaptiveFormats.forEach(callback);
        }
        else {
            this.videoInfo.streamingData.adaptiveFormats.forEach(audioCallback);
        }
        return {
            url: url,
            fmt: fmt
        };
    };
    /**
     * Returns the download `url` and other details about the specific `format`
     * searching by `itag`.
     * @param itag Stores the YouTube itag
     */
    VideoData.prototype.fetchFormatDataByItag = function (itag) {
        var url;
        var fmt;
        var tokens = this.videoInfo.tokens;
        function callback(format) {
            if (format.itag === itag) {
                fmt = format;
                if (format.url) {
                    url = format.url;
                }
                else {
                    var link = Object.fromEntries(new url_1.URLSearchParams(format.cipher || format.signatureCipher));
                    var sig = tokens && link.s ? signature_1.decipher(tokens, link.s) : null;
                    url = link.url + "&" + (link.sp || 'sig') + "=" + sig;
                }
            }
        }
        this.videoInfo.streamingData.formats.forEach(callback);
        if (!url) {
            this.videoInfo.streamingData.adaptiveFormats.forEach(callback);
        }
        return {
            url: url,
            fmt: fmt
        };
    };
    /**
     * Returns the size of the YouTube content, in `bytes`.
     * @param qualityLabelOrItag Stores the quality or itag
     * @param options Stores special options like audioOnly or videoOnly
     */
    VideoData.prototype.size = function (qualityLabelOrItag, options) {
        var format;
        if (typeof qualityLabelOrItag === 'string') {
            format = this.fetchFormatData(qualityLabelOrItag, options).fmt;
        }
        else if (typeof qualityLabelOrItag === 'number') {
            format = this.fetchFormatDataByItag(qualityLabelOrItag).fmt;
        }
        else {
            return 0;
        }
        if (!format)
            return 0;
        return Number(format.contentLength);
    };
    /**
     * Returns `id`, `title`, `time`, and `description`.
     */
    VideoData.prototype.all = function () {
        return {
            id: this.videoId,
            title: this.videoTitle,
            time: this.videoTime,
            description: this.videoDescription
        };
    };
    return VideoData;
}());
exports["default"] = VideoData;
